<!DOCTYPE html><html><head><meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Dynamics Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.8.0/lib/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        #canvas-container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            position: relative;
        }
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            font-family: Arial, sans-serif;
            text-align: center;
            pointer-events: none;
            z-index: 100;
        }
    </style>

<base target="_self">


    </head><body><div id="canvas-container"></div>
    <div class="instructions">Click and drag to interact with the fluid</div>

    <script>
        const fluidSim = (p) => {
            // Fluid simulation parameters
            let fluid;
            let cols, rows;
            let resolution = 20;
            let dt = 0.1;
            let viscosity = 0.0001;
            let diffusion = 0.0001;
            let iterations = 10;
            
            // Visual parameters
            let colorPalette = [];
            let particleCount = 2000;
            let particles = [];
            let flowField = [];
            let lastMousePos = p.createVector(0, 0);
            let isMousePressed = false;
            let bgGraphics;
            
            p.setup = () => {
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
                canvas.parent('canvas-container');
                
                // Initialize color palette
                colorPalette = [
                    p.color(10, 20, 100),
                    p.color(50, 100, 200),
                    p.color(150, 200, 255),
                    p.color(200, 150, 255),
                    p.color(255, 100, 200)
                ];
                
                // Calculate grid dimensions
                cols = Math.floor(p.width / resolution);
                rows = Math.floor(p.height / resolution);
                
                // Initialize fluid simulation
                fluid = {
                    density: new Array(cols * rows).fill(0),
                    velocityX: new Array(cols * rows).fill(0),
                    velocityY: new Array(cols * rows).fill(0),
                    prevDensity: new Array(cols * rows).fill(0),
                    prevVelocityX: new Array(cols * rows).fill(0),
                    prevVelocityY: new Array(cols * rows).fill(0)
                };
                
                // Initialize particles
                for (let i = 0; i < particleCount; i++) {
                    particles.push({
                        pos: p.createVector(p.random(p.width), p.random(p.height)),
                        vel: p.createVector(0, 0),
                        color: colorPalette[p.floor(p.random(colorPalette.length))],
                        size: p.random(1, 3),
                        life: p.random(100, 200)
                    });
                }
                
                // Create flow field
                for (let i = 0; i < cols; i++) {
                    flowField[i] = [];
                    for (let j = 0; j < rows; j++) {
                        flowField[i][j] = p.createVector(0, 0);
                    }
                }
                
                // Create background graphics
                bgGraphics = p.createGraphics(p.width, p.height);
                drawBackground();
                
                p.colorMode(p.HSB, 360, 100, 100, 1);
                p.noStroke();
            };
            
            p.draw = () => {
                // Apply forces based on mouse interaction
                if (isMousePressed) {
                    const mouseX = p.mouseX + p.width/2;
                    const mouseY = p.mouseY + p.height/2;
                    const prevMouseX = lastMousePos.x + p.width/2;
                    const prevMouseY = lastMousePos.y + p.height/2;
                    
                    const forceX = (mouseX - prevMouseX) * 0.5;
                    const forceY = (mouseY - prevMouseY) * 0.5;
                    
                    addForce(Math.floor(mouseX / resolution), Math.floor(mouseY / resolution), forceX, forceY);
                    addDensity(Math.floor(mouseX / resolution), Math.floor(mouseY / resolution), 50);
                }
                
                lastMousePos.set(p.mouseX, p.mouseY);
                
                // Update fluid simulation
                updateFluid();
                
                // Update flow field
                updateFlowField();
                
                // Update particles
                updateParticles();
                
                // Draw everything
                p.background(0);
                p.image(bgGraphics, -p.width/2, -p.height/2);
                drawParticles();
                
                // Fade out the canvas slightly for motion trails
                bgGraphics.push();
                bgGraphics.blendMode(p.BLEND);
                bgGraphics.background(0, 0, 0, 10);
                bgGraphics.pop();
                drawBackground();
            };
            
            function drawBackground() {
                bgGraphics.push();
                bgGraphics.noStroke();
                
                // Draw fluid density
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        const index = i + j * cols;
                        const d = fluid.density[index];
                        
                        if (d > 0.1) {
                            const x = i * resolution;
                            const y = j * resolution;
                            const col = p.lerpColor(colorPalette[0], colorPalette[colorPalette.length-1], p.constrain(d/50, 0, 1));
                            col.setAlpha(p.constrain(d * 2, 0, 100));
                            
                            bgGraphics.fill(col);
                            bgGraphics.rect(x, y, resolution, resolution);
                        }
                    }
                }
                
                bgGraphics.pop();
            }
            
            function updateFluid() {
                diffuse(0, fluid.prevVelocityX, fluid.velocityX, viscosity, dt);
                diffuse(1, fluid.prevVelocityY, fluid.velocityY, viscosity, dt);
                
                project(fluid.prevVelocityX, fluid.prevVelocityY, fluid.velocityX, fluid.velocityY);
                
                advect(0, fluid.velocityX, fluid.prevVelocityX, fluid.prevVelocityX, fluid.prevVelocityY, dt);
                advect(1, fluid.velocityY, fluid.prevVelocityY, fluid.prevVelocityX, fluid.prevVelocityY, dt);
                
                project(fluid.velocityX, fluid.velocityY, fluid.prevVelocityX, fluid.prevVelocityY);
                
                diffuse(0, fluid.prevDensity, fluid.density, diffusion, dt);
                advect(0, fluid.density, fluid.prevDensity, fluid.velocityX, fluid.velocityY, dt);
                
                // Fade out density over time
                for (let i = 0; i < fluid.density.length; i++) {
                    fluid.density[i] *= 0.99;
                    if (fluid.density[i] < 0.1) fluid.density[i] = 0;
                }
            }
            
            function diffuse(b, x, x0, diff, dt) {
                const a = dt * diff * (cols - 2) * (rows - 2);
                for (let k = 0; k < iterations; k++) {
                    for (let i = 1; i < cols - 1; i++) {
                        for (let j = 1; j < rows - 1; j++) {
                            const index = i + j * cols;
                            x[index] = (x0[index] + a * (
                                x[index - 1] +
                                x[index + 1] +
                                x[index - cols] +
                                x[index + cols]
                            )) / (1 + 4 * a);
                        }
                    }
                    setBoundary(b, x);
                }
            }
            
            function project(velocX, velocY, p, div) {
                for (let i = 1; i < cols - 1; i++) {
                    for (let j = 1; j < rows - 1; j++) {
                        const index = i + j * cols;
                        div[index] = -0.5 * (
                            velocX[index + 1] -
                            velocX[index - 1] +
                            velocY[index + cols] -
                            velocY[index - cols]
                        ) / cols;
                        p[index] = 0;
                    }
                }
                
                setBoundary(0, div);
                setBoundary(0, p);
                
                for (let k = 0; k < iterations; k++) {
                    for (let i = 1; i < cols - 1; i++) {
                        for (let j = 1; j < rows - 1; j++) {
                            const index = i + j * cols;
                            p[index] = (
                                div[index] +
                                p[index - 1] +
                                p[index + 1] +
                                p[index - cols] +
                                p[index + cols]
                            ) / 4;
                        }
                    }
                    setBoundary(0, p);
                }
                
                for (let i = 1; i < cols - 1; i++) {
                    for (let j = 1; j < rows - 1; j++) {
                        const index = i + j * cols;
                        velocX[index] -= 0.5 * (p[index + 1] - p[index - 1]) * cols;
                        velocY[index] -= 0.5 * (p[index + cols] - p[index - cols]) * cols;
                    }
                }
                setBoundary(1, velocX);
                setBoundary(2, velocY);
            }
            
            function advect(b, d, d0, velocX, velocY, dt) {
                let i0, i1, j0, j1;
                let s0, s1, t0, t1;
                let dt0 = dt * cols;
                let dt1 = dt * rows;
                
                for (let i = 1; i < cols - 1; i++) {
                    for (let j = 1; j < rows - 1; j++) {
                        const index = i + j * cols;
                        let x = i - dt0 * velocX[index];
                        let y = j - dt1 * velocY[index];
                        
                        x = p.constrain(x, 0.5, cols - 1.5);
                        i0 = p.floor(x);
                        i1 = i0 + 1;
                        s1 = x - i0;
                        s0 = 1 - s1;
                        
                        y = p.constrain(y, 0.5, rows - 1.5);
                        j0 = p.floor(y);
                        j1 = j0 + 1;
                        t1 = y - j0;
                        t0 = 1 - t1;
                        
                        d[index] = s0 * (t0 * d0[i0 + j0 * cols] + t1 * d0[i0 + j1 * cols]) +
                                   s1 * (t0 * d0[i1 + j0 * cols] + t1 * d0[i1 + j1 * cols]);
                    }
                }
                setBoundary(b, d);
            }
            
            function setBoundary(b, x) {
                for (let i = 1; i < cols - 1; i++) {
                    x[i] = b === 1 ? -x[i + cols] : x[i + cols];
                    x[i + (rows - 1) * cols] = b === 1 ? -x[i + (rows - 2) * cols] : x[i + (rows - 2) * cols];
                }
                
                for (let j = 1; j < rows - 1; j++) {
                    x[j * cols] = b === 2 ? -x[1 + j * cols] : x[1 + j * cols];
                    x[cols - 1 + j * cols] = b === 2 ? -x[cols - 2 + j * cols] : x[cols - 2 + j * cols];
                }
                
                x[0] = 0.5 * (x[1] + x[cols]);
                x[cols - 1] = 0.5 * (x[cols - 2] + x[cols * 2 - 1]);
                x[(rows - 1) * cols] = 0.5 * (x[(rows - 2) * cols] + x[(rows - 1) * cols + 1]);
                x[cols * rows - 1] = 0.5 * (x[cols * rows - 2] + x[cols * (rows - 1) - 1]);
            }
            
            function addForce(x, y, fx, fy) {
                const index = x + y * cols;
                if (index >= 0 && index < fluid.velocityX.length) {
                    fluid.velocityX[index] += fx;
                    fluid.velocityY[index] += fy;
                }
            }
            
            function addDensity(x, y, amount) {
                const index = x + y * cols;
                if (index >= 0 && index < fluid.density.length) {
                    fluid.density[index] += amount;
                }
            }
            
            function updateFlowField() {
                for (let i = 0; i < cols; i++) {
                    for (let j = 0; j < rows; j++) {
                        const index = i + j * cols;
                        flowField[i][j].set(fluid.velocityX[index], fluid.velocityY[index]);
                    }
                }
            }
            
            function updateParticles() {
                for (let particle of particles) {
                    // Update position based on velocity
                    particle.pos.add(particle.vel);
                    
                    // Apply flow field forces
                    const gridX = p.constrain(Math.floor(particle.pos.x / resolution), 0, cols - 1);
                    const gridY = p.constrain(Math.floor(particle.pos.y / resolution), 0, rows - 1);
                    
                    const force = flowField[gridX][gridY];
                    particle.vel.add(force);
                    particle.vel.mult(0.98); // Damping
                    
                    // Wrap around edges
                    if (particle.pos.x < 0) particle.pos.x = p.width;
                    if (particle.pos.x > p.width) particle.pos.x = 0;
                    if (particle.pos.y < 0) particle.pos.y = p.height;
                    if (particle.pos.y > p.height) particle.pos.y = 0;
                    
                    // Life cycle
                    particle.life -= 0.5;
                    if (particle.life <= 0) {
                        particle.pos.set(p.random(p.width), p.random(p.height));
                        particle.vel.set(0, 0);
                        particle.life = p.random(100, 200);
                        particle.color = colorPalette[p.floor(p.random(colorPalette.length))];
                    }
                }
            }
            
            function drawParticles() {
                p.push();
                p.translate(-p.width/2, -p.height/2);
                p.blendMode(p.ADD);
                
                for (let particle of particles) {
                    const alpha = p.map(particle.life, 0, 200, 0, 1);
                    const col = p.color(
                        p.hue(particle.color),
                        p.saturation(particle.color),
                        p.brightness(particle.color),
                        alpha * 0.5
                    );
                    
                    p.fill(col);
                    p.circle(particle.pos.x, particle.pos.y, particle.size * alpha);
                }
                
                p.pop();
            }
            
            p.mousePressed = () => {
                isMousePressed = true;
            };
            
            p.mouseReleased = () => {
                isMousePressed = false;
            };
            
            p.touchStarted = () => {
                isMousePressed = true;
                return false;
            };
            
            p.touchEnded = () => {
                isMousePressed = false;
                return false;
            };
            
            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                bgGraphics = p.createGraphics(p.width, p.height);
                drawBackground();
                
                // Recalculate grid dimensions
                cols = Math.floor(p.width / resolution);
                rows = Math.floor(p.height / resolution);
                
                // Reinitialize fluid simulation
                fluid = {
                    density: new Array(cols * rows).fill(0),
                    velocityX: new Array(cols * rows).fill(0),
                    velocityY: new Array(cols * rows).fill(0),
                    prevDensity: new Array(cols * rows).fill(0),
                    prevVelocityX: new Array(cols * rows).fill(0),
                    prevVelocityY: new Array(cols * rows).fill(0)
                };
                
                // Reinitialize flow field
                flowField = [];
                for (let i = 0; i < cols; i++) {
                    flowField[i] = [];
                    for (let j = 0; j < rows; j++) {
                        flowField[i][j] = p.createVector(0, 0);
                    }
                }
            };
        };

        new p5(fluidSim);
    </script>

              
          
                
          
              
</body></html>